#!/usr/bin/env python3
"""
Генеруємо константи для NTT над модулем q = 8380417, N = 256.

Результат:
- OMEGA (512-й первісний корінь)
- N_INV = 256^{-1} mod q
- Таблиця twiddle-факторів у вигляді Solidity-функції getZeta(i)
"""

Q = 8380417
N = 256
OMEGA = 1753   # ML-DSA/Dilithium primitive root


def egcd(a, b):
    if b == 0:
        return (a, 1, 0)
    g, x1, y1 = egcd(b, a % b)
    return (g, y1, x1 - (a // b) * y1)


def modinv(a, m):
    g, x, _ = egcd(a, m)
    if g != 1:
        raise ValueError("No modular inverse")
    return x % m


def bit_reverse(x, bits):
    r = 0
    for _ in range(bits):
        r = (r << 1) | (x & 1)
        x >>= 1
    return r


def main():
    # Перевіряємо корінь
    w256 = pow(OMEGA, 256, Q)
    w512 = pow(OMEGA, 512, Q)

    print(f"// omega^256 mod Q = {w256} (очікуємо {Q-1})")
    print(f"// omega^512 mod Q = {w512} (очікуємо 1)\n")

    # Інверсія 256 mod Q
    n_inv = modinv(N, Q)
    print(f"// N_INV = {n_inv}\n")

    # Генеруємо 256 twiddle-факторів
    bits = 8
    zetas = []
    for i in range(N):
        e = bit_reverse(i, bits)
        z = pow(OMEGA, e, Q)
        zetas.append(z)

    # Solidity-функція
    print("    // AUTO-GENERATED BY scripts/gen_ntt_twiddles.py")
    print("    function getZeta(uint256 i) internal pure returns (uint256) {")
    print("        unchecked {")
    print("            if (i >= 256) revert(\"Zeta index out of range\");")

    for i, z in enumerate(zetas):
        prefix = "            if" if i == 0 else "            else if"
        print(f"{prefix} (i == {i}) return {z};")

    print("        }")
    print("        return 0; // unreachable")
    print("    }\n")

    print(f"    uint256 constant N_INV = {n_inv};")


if __name__ == "__main__":
    main()
